rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Community profiles - users can only read/write their own profile
    match /community_profiles/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
    
    // Posts - authenticated users can read all posts, but only create their own
    match /posts/{postId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null && request.auth.uid == request.resource.data.userId;
      allow update, delete: if request.auth != null && request.auth.uid == resource.data.userId;
      
      // Allow updating like and comment counts
      allow update: if request.auth != null && 
        (request.auth.uid == resource.data.userId || 
         (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['likes', 'comments'])));
      
      // Comments subcollection
      match /comments/{commentId} {
        allow read: if request.auth != null;
        allow create: if request.auth != null && request.auth.uid == request.resource.data.userId;
        allow update: if request.auth != null && request.auth.uid == resource.data.userId;
        allow delete: if request.auth != null && request.auth.uid == resource.data.userId;
        
        // Allow updating like counts on comments
        allow update: if request.auth != null && 
          (request.auth.uid == resource.data.userId || 
           (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['likes', 'replyCount'])));
        
        // Likes subcollection for comments
        match /likes/{userId} {
          allow read, write: if request.auth != null && request.auth.uid == userId;
        }
      }
      
      // Likes subcollection for posts
      match /likes/{userId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
    }
    
    // Users collection
    match /users/{userId} {
      allow read: if request.auth != null; // Allow any authenticated user to read user profiles
      allow write: if request.auth != null && request.auth.uid == userId;
      allow list: if request.auth != null; // Allow listing users for search functionality
    }
    
    // Study materials collection
    match /study_materials/{materialId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null;
      // Allow document owner to update/delete the entire document
      allow update, delete: if request.auth != null && request.auth.uid == resource.data.authorId;
      // Allow any authenticated user to update only view, download, like, and comment counts
      allow update: if request.auth != null && 
        (request.auth.uid == resource.data.authorId || 
         (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['views', 'downloads', 'likes', 'commentCount', 'likedBy'])));
      allow list: if request.auth != null; // Allow listing study materials
    }
    
    // Document ratings collection
    match /document_ratings/{ratingId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null;
      allow update: if request.auth != null && request.auth.uid == resource.data.userId;
      allow delete: if request.auth != null && request.auth.uid == resource.data.userId;
      allow list: if request.auth != null; // Allow listing ratings
    }
    
    // Comments collection (for study materials)
    match /comments/{commentId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null;
      // Allow comment author to update their own comment
      allow update: if request.auth != null && request.auth.uid == resource.data.userId;
      // Allow any authenticated user to update only replyCount (for reply functionality)
      allow update: if request.auth != null && 
        (request.auth.uid == resource.data.userId || 
         (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['replyCount'])));
      allow delete: if request.auth != null && request.auth.uid == resource.data.userId;
      allow list: if request.auth != null; // Allow listing comments
    }
    
    // User favorites collection
    match /user_favorites/{favoriteId} {
      allow read: if request.auth != null && request.auth.uid == resource.data.userId;
      allow create: if request.auth != null && request.auth.uid == request.resource.data.userId;
      allow update: if request.auth != null && request.auth.uid == resource.data.userId;
      allow delete: if request.auth != null && request.auth.uid == resource.data.userId;
      allow list: if request.auth != null;
    }
    
    // User follows collection
    match /user_follows/{followId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null && request.auth.uid == request.resource.data.followerId;
      allow update: if request.auth != null && request.auth.uid == resource.data.followerId;
      allow delete: if request.auth != null && request.auth.uid == resource.data.followerId;
      allow list: if request.auth != null;
    }

    // View and download tracking collection
    match /view_download_tracking/{trackingId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null;
      allow update: if request.auth != null;
      allow delete: if request.auth != null;
      allow list: if request.auth != null;
    }

    // Chat rooms collection
    match /chatRooms/{roomId} {
      allow read, write: if request.auth != null && 
        (resource == null || request.auth.uid in resource.data.memberIds);
      allow list: if request.auth != null; // Allow listing chat rooms
    }
    
    // Messages collection
    match /messages/{messageId} {
      allow read, write: if request.auth != null && 
        (resource == null || request.auth.uid in get(/databases/$(database)/documents/chatRooms/$(resource.data.roomId)).data.memberIds);
      allow list: if request.auth != null; // Allow listing messages
    }
    
    // Study tasks collection
    match /studyTasks/{taskId} {
      allow read, write: if request.auth != null && 
        (resource == null || request.auth.uid in get(/databases/$(database)/documents/chatRooms/$(resource.data.groupId)).data.memberIds);
      allow list: if request.auth != null; // Allow listing study tasks
    }
    
    // Enhanced Private chats rules
    match /private_chats/{chatId} {
      // Allow read/write only for participants
      allow read, write: if request.auth != null &&
        request.auth.uid in resource.data.participants;

      // Allow creation if user is in participants list
      allow create: if request.auth != null &&
        request.auth.uid in request.resource.data.participants;

      // Allow specific updates for message metadata and unread counts
      allow update: if request.auth != null &&
        request.auth.uid in resource.data.participants &&
        (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['unreadCounts', 'lastMessage', 'lastMessageTime', 'lastMessageSenderId', 'updatedAt']) ||
         // Allow users to clear their own unread count
         (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['unreadCounts']) &&
          request.resource.data.unreadCounts.keys().hasOnly([request.auth.uid])));

      // Messages subcollection
      match /messages/{messageId} {
        allow read, write: if request.auth != null;
      }
    }

    // Group chats collection (enhanced)
    match /group_chats/{groupId} {
      // Allow read for public groups or if user is a member/admin
      allow read: if request.auth != null &&
        (resource.data.isPublic == true ||
         request.auth.uid in resource.data.members ||
         request.auth.uid in resource.data.admins ||
         request.auth.uid in resource.data.pendingInvitations);

      // Allow create if user is authenticated
      allow create: if request.auth != null &&
        request.auth.uid == request.resource.data.createdBy;

      // Allow update if user is admin OR for specific field updates
      allow update: if request.auth != null &&
        (request.auth.uid in resource.data.admins ||
         // Allow system to add users to members array (for invitation acceptance)
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['members', 'unreadCounts', 'pendingInvitations']) ||
         // Allow updating last message and unread counts (for message sending)
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['lastMessage', 'lastMessageSenderId', 'lastMessageTime', 'updatedAt', 'unreadCounts']) ||
         // Allow updating only unread counts (for clearing/incrementing counts)
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['unreadCounts']) ||
         // Allow members to clear their own unread count
         (request.auth.uid in resource.data.members &&
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['unreadCounts']) &&
          request.resource.data.unreadCounts.keys().hasOnly([request.auth.uid])));

      // Allow delete only for group creator
      allow delete: if request.auth != null &&
        request.auth.uid == resource.data.createdBy;
    }

    // Group messages collection - SIMPLIFIED AND FIXED
    match /group_messages/{messageId} {
      // Allow read for authenticated users (we'll handle group membership in the app)
      allow read: if request.auth != null;

      // Allow create for authenticated users (simplified - app handles membership)
      allow create: if request.auth != null &&
        request.auth.uid == request.resource.data.senderId;

      // Allow update only for sender (for editing)
      allow update: if request.auth != null &&
        request.auth.uid == resource.data.senderId;

      // Allow system messages (senderId = "system")
      allow create: if request.auth != null &&
        request.resource.data.senderId == "system";
    }

    // Group invitations collection
    match /group_invitations/{invitationId} {
      // Allow read if user is the inviter or invitee
      allow read: if request.auth != null &&
        (request.auth.uid == resource.data.invitedBy ||
         request.auth.uid == resource.data.invitedUser);

      // Allow create if user is authenticated and is the inviter
      allow create: if request.auth != null &&
        request.auth.uid == request.resource.data.invitedBy;

      // Allow update if user is the invitee (for accepting/declining)
      allow update: if request.auth != null &&
        request.auth.uid == resource.data.invitedUser;

      // Allow delete if user is inviter or invitee
      allow delete: if request.auth != null &&
        (request.auth.uid == resource.data.invitedBy ||
         request.auth.uid == resource.data.invitedUser);
    }

    // Rules for calls collection with WebRTC signaling support
    match /calls/{callId} {
      // Allow users to read calls where they are either caller or receiver
      allow read: if request.auth != null &&
        (request.auth.uid == resource.data.callerId ||
         request.auth.uid == resource.data.receiverId);

      // Allow users to create calls where they are the caller
      allow create: if request.auth != null &&
        request.auth.uid == request.resource.data.callerId;

      // Allow users to update calls where they are either caller or receiver
      // This includes status updates and WebRTC signaling data
      allow update: if request.auth != null &&
        (request.auth.uid == resource.data.callerId ||
         request.auth.uid == resource.data.receiverId);
    }

    // Notifications collection
    match /notifications/{notificationId} {
      allow read: if request.auth != null && request.auth.uid == resource.data.recipientId;
      allow create: if request.auth != null;
      allow update: if request.auth != null && request.auth.uid == resource.data.recipientId;
      allow delete: if request.auth != null && request.auth.uid == resource.data.recipientId;
    }
    
    // Default rule - deny all other access
    match /{document=**} {
      allow read, write: if false;
    }
  }
} 